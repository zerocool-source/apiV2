You are a senior backend engineer. Build API v2 for a commercial pool operations mobile app.

Tech stack:
- Fastify + TypeScript (ESM)
- PostgreSQL + Prisma
- JWT auth (Bearer tokens)
- Replit friendly (listen host 0.0.0.0, port from process.env.PORT)
- Render deploy from GitHub (build + start scripts, prisma migrate deploy)

Hard requirements:
1) Base path prefix: ALL endpoints under /api
2) JSON only. Standard error format everywhere:
   { "error": "STRING_CODE", "message": "Human readable", "details"?: any }
3) Auth:
   - POST /api/auth/login (existing)
   - POST /api/auth/register (existing)
   - POST /api/auth/logout (existing; can be token blacklist stub or client-side logout but endpoint must exist)
   JWT payload includes: sub (userId), role
4) Roles: "tech", "supervisor", "repair", "admin"
   Provide RBAC middleware:
   - requireAuth
   - requireRole([...])
5) CORS configurable via env: CORS_ORIGIN="*" by default in dev, specific origins in prod.
6) Include request validation with Zod on all endpoints.
7) Include OpenAPI/Swagger OPTIONAL, but default OFF to keep minimal. If included, put it under /docs.
8) Provide a seed script that creates:
   - admin user (admin@breakpoint.local / password123)
   - supervisor user (supervisor@breakpoint.local / password123)
   - tech user (tech@breakpoint.local / password123)
   - repair user (repair@breakpoint.local / password123)
   In development only.

Deliverables: output ALL code files with paths:
- package.json with scripts:
  dev: "tsx watch src/index.ts"
  build: "npx prisma generate && tsc"
  start: "node dist/index.js"
  prisma:migrate: "prisma migrate deploy"
  prisma:generate: "prisma generate"
  seed: "tsx prisma/seed.ts"
- tsconfig.json
- prisma/schema.prisma with models needed for the endpoints below
- src/index.ts (only boot server)
- src/app.ts (buildApp registers plugins + routes)
- src/plugins/prisma.ts
- src/plugins/jwt.ts (jwt + auth decorators)
- src/plugins/rbac.ts (helpers)
- src/utils/env.ts (zod env validation)
- src/utils/password.ts (bcrypt)
- src/routes/* files grouped by domain

Existing endpoints to keep working (API v1 behavior must be preserved):
- POST /api/auth/login
- POST /api/auth/register
- POST /api/auth/logout
- GET  /api/properties
- GET  /api/assignments
- PATCH /api/assignments/:id
- GET/POST/DELETE /api/property-channels
- GET  /api/route-stops
- GET  /api/technicians
- POST /api/assignments
- GET  /api/assignments/created
- GET/POST/DELETE /api/roster

Missing endpoints to implement in v2 (must exist with sane schemas):
HIGH PRIORITY
1) Complete Property
   - POST /api/properties/:id/complete
   Body: assignmentId, completedAt, checklistResponses[], chemicalReadings?, notes?, photos?
2) Emergency Reports
   - POST /api/emergencies
   Body: propertyId, assignmentId?, severity, category, description, actionsTaken?, photos?
3) Team Tracker / Who’s On
   - POST /api/locations (tech posts GPS updates)
   - GET  /api/technicians/locations (supervisor views)
   - GET  /api/technicians/status (clock in/out + current assignment/property)
4) Chat Messages
   - GET  /api/messages?channelId=... OR ?toUserId=...
   - POST /api/messages
   - GET/POST/DELETE /api/property-channels (already exists, ensure it supports channels)
MEDIUM PRIORITY
5) Truck Inventory
   - GET  /api/truck-inventory?truckId=...
   - POST /api/truck-inventory (add item)
   - PATCH /api/truck-inventory/:id (adjust qty)
6) QC Inspections
   - GET  /api/inspections?propertyId=...
   - POST /api/inspections
7) Metrics Dashboard
   - GET /api/metrics (completed/in-progress, alerts count)
8) Alerts
   - GET  /api/alerts
   - POST /api/alerts (supervisor broadcast)
LOW PRIORITY / SYSTEM
9) Repairs Needed + Service Repairs + Chemical Orders
   - POST /api/repairs
   - POST /api/service-repairs
   - POST /api/chemical-orders
10) Repair Tech Jobs + Estimates + Products + Time Entries
   - GET  /api/jobs?type=repair
   - PATCH /api/jobs/:id
   - GET/POST /api/estimates
   - GET  /api/products
   - POST /api/time-entries
11) Offline sync queue
   - POST /api/sync (batch upload queued actions)
12) Uploads
   - POST /api/uploads (accept multipart file; return url)
   Use a local disk storage implementation for dev and a pluggable interface for S3 later.

Data model guidance (Prisma):
- User (role, email, passwordHash)
- TechnicianProfile (userId, name, phone, truckId?, active)
- Property (name, address, geo?)
- Assignment (propertyId, technicianId, status, scheduledDate, completedAt?)
- RouteStop (assignmentId, order, eta?)
- PropertyChannel (propertyId, channelId, createdBy)
- Message (channelId?, fromUserId, toUserId?, propertyId?, text, createdAt)
- EmergencyReport (propertyId, createdBy, severity, category, description, createdAt)
- LocationPing (userId, lat, lng, timestamp)
- TechnicianStatus (userId, clockedIn, currentPropertyId?, currentAssignmentId?)
- ChecklistTemplate (propertyId?, name)
- ChecklistResponse (assignmentId, propertyId, responses JSON)
- ChemicalReading (assignmentId, propertyId, ph, chlorine, alkalinity, cya?, orp?, timestamp)
- TruckInventoryItem (truckId, sku/name, qty, unit)
- Inspection (propertyId, inspectorUserId, type, results JSON, createdAt)
- Alert (createdBy, title, message, severity, audience, createdAt, expiresAt?)
- RepairRequest (propertyId, createdBy, description, priority, createdAt)
- ServiceRepair (propertyId, createdBy, details JSON, createdAt)
- ChemicalOrder (propertyId?, createdBy, items JSON, createdAt)
- Job (type, propertyId, assignedToUserId, status, createdAt)
- Estimate (jobId, createdBy, lines JSON, total)
- Product (sku, name, category, price)
- TimeEntry (jobId, userId, minutes, notes, createdAt)
- Upload (createdBy, propertyId?, url, mime, createdAt)
- SyncBatch (userId, payload JSON, createdAt)

Implementation notes:
- Use cursor pagination for /api/messages.
- For locations, allow supervisors to query last known per tech.
- Provide minimal “in-memory” or DB-based alert retrieval first (no push notifications required yet).
- All endpoints should have stub responses only if marked optional; otherwise implement working DB logic.

Finally, include a README.md with:
- How to run in Replit (set env vars, run npm run dev, open /api/health)
- How to deploy to Render (env vars, build/start, migrations)
- Example curl commands for login and posting a location ping

Output everything as code blocks with file paths.
